<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Interactive Snell's Law Simulator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f4f6f9;
    }

    .container {
      margin-top: 20px;
    }

    canvas {
      border: 1px solid black;
      background: white;
      margin-top: 20px;
      max-width: 100%;
      height: auto;
    }

    input {
      margin: 5px;
    }

    .custom-controls {
      display: inline-block;
      vertical-align: middle;
    }

    .hidden {
      display: none;
    }

    .indices {
      display: flex;
      gap: 18px;
      justify-content: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .index-block {
      background: #ffffffaa;
      padding: 12px 16px;
      border-radius: 8px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      min-width: 260px;
      text-align: left;
      min-height: 80px;
    }

    .index-block label {
      display: inline-block;
      margin-bottom: 6px;
      font-weight: bold;
      font-size: 16px;
    }

    .value-display {
      margin-top: 8px;
      font-size: 14px;
      color: #333;
      display: block;
    }

    .value-display .custom-controls:not(.hidden) {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 6px;
    }

    select {
      min-width: 160px;
      height: 40px;
      font-size: 15px;
    }

    .custom-controls input[type="number"] {
      width: 88px;
      height: 40px;
      box-sizing: border-box;
      padding: 6px 8px;
      font-size: 15px;
    }

    .custom-controls button {
      padding: 6px 10px;
      font-size: 15px;
      border-radius: 6px;
    }

    .angle-block {
      background: #ffffffaa;
      padding: 10px 14px;
      border-radius: 6px;
      display: inline-block;
      min-width: 360px;
      text-align: center;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
      margin: 20px auto 8px;
    }

    .controls-center {
      background: #ffffffaa;
      padding: 10px 14px;
      border-radius: 6px;
      width: 100%;
      margin: 12px 0;
      text-align: center;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
      box-sizing: border-box;
    }


    .angle-block label {
      font-weight: bold;
      display: block;
      margin-bottom: 6px;
      text-align: center;
    }

    .angle-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: center;
    }

    .angle-checkbox {
      margin-bottom: 12px;
    }

    .angle-controls input[type="range"] {
      width: 60%;
      max-width: 720px;
      height: 12px;
    }

    /* larger range thumb for better touch targets */
    input[type=range]::-webkit-slider-runnable-track {
      height: 10px;
      background: #ddd;
      border-radius: 6px;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 26px;
      height: 26px;
      background: #0b66c2;
      border-radius: 50%;
      margin-top: -7px;
    }

    input[type=range]::-moz-range-track {
      height: 10px;
      background: #ddd;
      border-radius: 6px;
    }

    input[type=range]::-moz-range-thumb {
      width: 26px;
      height: 26px;
      background: #0b66c2;
      border-radius: 50%;
    }

    /* Mobile / tablet adjustments */
    @media (max-width: 900px) {
      body {
        font-size: 16px;
      }

      .indices {
        flex-direction: row;
        gap: 12px;
      }

      /* Make the index blocks larger for easier tapping */
      .index-block {
        min-width: auto;
        width: 50%;
        margin: 0 auto;
        padding: 16px 18px;
        min-height: 92px;
      }

      .index-block label {
        font-size: 18px;
      }

      .index-block select {
        width: 100%;
        height: 48px;
        font-size: 17px;
      }

      .value-display {
        margin-top: 10px;
        font-size: 16px;
      }

      .angle-block {
        width: 94%;
        box-sizing: border-box;
        padding: 18px;
        min-height: 110px;
      }

      .angle-block label {
        font-size: 18px;
      }

      select,
      .custom-controls input[type="number"] {
        font-size: 17px;
      }

      .custom-controls input[type="number"] {
        width: 88px;
        height: 44px;
      }

      /* Larger, easy-to-tap controls */
      .index-block button,
      .custom-controls button,
      button,
      select,
      .custom-controls input[type="number"] {
        min-height: 48px;
        padding: 8px 14px;
        font-size: 17px;
        border-radius: 8px;
        touch-action: manipulation;
      }

      button {
        padding: 8px 14px;
      }

      .angle-controls input[type="range"] {
        width: 72%;
      }
    }

    @media (max-width: 420px) {
      body {
        font-size: 17px;
      }

      .indices {
        display: flex;
        gap: 16px;
        width: 100%;
      }

      .index-block {
        flex: 1;
        min-width: 0;
        background: #fff;
        padding: 16px;
        border-radius: 10px;
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.06);
        box-sizing: border-box;
      }

      .custom-controls input[type="number"] {
        width: 96px;
      }

      .angle-controls input[type="range"] {
        width: 68%;
      }

      .value-display {
        font-size: 15px;
      }
    }

    button {
      padding: 3px 8px;
    }

    .result {
      margin-top: 15px;
      font-size: 18px;
    }

    .warning {
      color: red;
      font-weight: bold;
    }
  </style>
</head>

<body>

  <h2>สื่อจำลองการหักเหของแสง <br>(Snell's Law)</h2>

  <div class="container">
    <div class="indices">
      <div class="index-block">
        <label for="n1select">ตัวกลางที่ 1 :</label><br>
        <select id="n1select">
          <option value="1.0000">สุญญากาศ</option>
          <option value="1.0003" selected>อากาศ</option>
          <option value="1.33">น้ำ</option>
          <option value="1.50">แก้วทั่วไป</option>
          <option value="2.42">เพชร</option>
          <option value="custom">กำหนดเอง</option>
        </select>
        <div class="value-display">ค่าดัชนีหักเหของแสง(n₁) : <span id="n1value">1.0000</span>
          <span id="n1custom" class="custom-controls hidden">
            <button id="n1minus">−</button>
            <input type="number" id="n1" value="1.00" step="0.01">
            <button id="n1plus">+</button>
          </span>
        </div>
      </div>

      <div class="index-block">
        <label for="n2select">ตัวกลางที่ 2 :</label><br>
        <select id="n2select">
          <option value="1.0000">สุญญากาศ</option>
          <option value="1.0003">อากาศ</option>
          <option value="1.33" selected>น้ำ</option>
          <option value="1.50">แก้วทั่วไป</option>
          <option value="2.42">เพชร</option>
          <option value="custom">กำหนดเอง</option>
        </select>
        <div class="value-display">ค่าดัชนีหักเหของแสง(n₂) : <span id="n2value">1.3300</span>
          <span id="n2custom" class="custom-controls hidden">
            <button id="n2minus">−</button>
            <input type="number" id="n2" value="1.33" step="0.01">
            <button id="n2plus">+</button>
          </span>
        </div>
      </div>
    </div>
  </div>

  <canvas id="canvas" width="600" height="400"></canvas>

  <div class="result" id="result"></div>

  <!-- moved angle controls here so the slider sits below the result text -->
  <div class="angle-block" id="angleBlockBelow">
    <label for="angle">มุมตกกระทบ (θ₁): <div style="min-width:56px"> <span id="angleValue">30</span>°</div></label>
    <div class="angle-controls">
      <input type="range" id="angle" min="0" max="89" value="30">

    </div>
  </div>
  <div class="container">
    <div class="indices">
      <!-- place a centered controls box below the index blocks -->
      <div class="controls-center">
        <label><input type="checkbox" id="showAngles" checked> แสดงมุมในรูป</label>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const n1Select = document.getElementById("n1select");
      const n2Select = document.getElementById("n2select");
      const n1Input = document.getElementById("n1");
      const n2Input = document.getElementById("n2");
      const n1Custom = document.getElementById("n1custom");
      const n2Custom = document.getElementById("n2custom");
      const n1ValueSpan = document.getElementById("n1value");
      const n2ValueSpan = document.getElementById("n2value");
      const angleSlider = document.getElementById("angle");
      const angleValue = document.getElementById("angleValue");
      const resultDiv = document.getElementById("result");
      const showAnglesCheckbox = document.getElementById("showAngles");
      const controlsCenter = document.querySelector('.controls-center');

      let holdTimer;

      // ===== ปุ่มกดแช่ =====
      function holdButton(btn, callback) {
        btn.addEventListener("mousedown", () => {
          callback();
          holdTimer = setInterval(callback, 100);
        });
        btn.addEventListener("mouseup", () => clearInterval(holdTimer));
        btn.addEventListener("mouseleave", () => clearInterval(holdTimer));
      }

      holdButton(document.getElementById("n1plus"), () => changeN1(0.01));
      holdButton(document.getElementById("n1minus"), () => changeN1(-0.01));
      holdButton(document.getElementById("n2plus"), () => changeN2(0.01));
      holdButton(document.getElementById("n2minus"), () => changeN2(-0.01));

      function changeN1(d) {
        let current = parseFloat(n1Input.value);

        if (isNaN(current)) current = 0;   // default = 0

        n1Input.value = Math.max(0, current + d).toFixed(2);
        updateDisplayedValues();
        draw();
      }

      function changeN2(d) {
        let current = parseFloat(n2Input.value);

        if (isNaN(current)) current = 0;   // default = 0

        n2Input.value = Math.max(0, current + d).toFixed(2);
        updateDisplayedValues();
        draw();
      }

      function validateInput(input) {
        let v = parseFloat(input.value);

        if (input.value.trim() === "" || isNaN(v)) {
          input.value = 0;
        } else if (v < 0) {
          input.value = 0;
        }

        draw();
      }

      // ===== วาด arc =====
      function drawArc(cx, cy, r, start, end, color) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, start, end);
        ctx.strokeStyle = color;
        ctx.stroke();
      }

      // ===== วาดป้ายพร้อมพื้นหลัง =====
      function drawLabel(x, y, text, color) {
        const padding = 4;
        ctx.font = "16px Arial";
        const metrics = ctx.measureText(text);
        const w = metrics.width + padding * 2;
        const h = 16 + padding * 2;
        ctx.fillStyle = "white";
        ctx.fillRect(x - w / 2, y - h / 2, w, h);
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x, y);
      }

      // ===== วาดหลัก =====
      function getNValue(selectElem, inputElem) {
        if (!selectElem) return parseFloat(inputElem.value) || 0;
        if (selectElem.value === 'custom') return parseFloat(inputElem.value) || 0;
        return parseFloat(selectElem.value) || 0;
      }

      function updateDisplayedValues() {
        if (n1ValueSpan) n1ValueSpan.textContent = (getNValue(n1Select, n1Input) || 0).toFixed(4);
        if (n2ValueSpan) n2ValueSpan.textContent = (getNValue(n2Select, n2Input) || 0).toFixed(4);
      }

      function draw() {
        const n1 = getNValue(n1Select, n1Input);
        const n2 = getNValue(n2Select, n2Input);
        const theta1Deg = parseFloat(angleSlider.value);
        const theta1 = theta1Deg * Math.PI / 180;

        angleValue.textContent = theta1Deg;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // use CSS pixel sizes (clientWidth/clientHeight) so drawing matches transform
        const displayWidth = canvas.clientWidth;
        const displayHeight = canvas.clientHeight;
        const centerX = displayWidth / 2;
        const centerY = displayHeight / 2;
        // ray length proportional to canvas size
        const length = Math.max(120, Math.min(displayWidth, displayHeight) * 0.45);

        function clampPoint(x, y) {
          return {
            x: Math.max(0, Math.min(displayWidth, x)),
            y: Math.max(0, Math.min(displayHeight, y))
          };
        }

        // เส้นแบ่ง (แนวนอน) – คงสีดำเสมอ
        ctx.strokeStyle = "black";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY);
        ctx.lineTo(canvas.width, centerY);
        ctx.stroke();

        // เส้นตั้งฉาก (แนวตั้ง แบบปะ)
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(centerX, 0);
        ctx.lineTo(centerX, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);

        // (แก้ไข) ไม่แสดงป้ายองศาบนแกนอีกต่อไป
        // Labels for axes removed as requested

        // ลำแสงตกกระทบ
        const x1 = centerX - length * Math.sin(theta1);
        const y1 = centerY - length * Math.cos(theta1);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(centerX, centerY);
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();

        // arc และป้ายเฉพาะเมื่อเลือกให้แสดงมุม
        const xOffset = -20; // เลื่อนป้ายไปทางซ้ายเพิ่มเติม
        const mid1 = -Math.PI / 2 - theta1 / 2;
        let labelRadius = 60;
        if (showAnglesCheckbox.checked) {
          // arc θ1
          drawArc(centerX, centerY, 40, -Math.PI / 2 - theta1, -Math.PI / 2, "red");
          const lx1 = centerX + labelRadius * Math.cos(mid1) + xOffset;
          const ly1 = centerY + labelRadius * Math.sin(mid1);
          ctx.fillStyle = "red";
          ctx.font = "16px Arial";
          drawLabel(lx1, ly1, `${theta1Deg.toFixed(1)}°`, "red");
        }


        const sinTheta2 = (n1 / n2) * Math.sin(theta1);

        // เริ่มต้นข้อความผลลัพธ์
        let resultHTML = `มุมตกกระทบ = ${theta1Deg}°<br>`;

        if (Math.abs(sinTheta2) <= 1) {
          const theta2 = Math.asin(sinTheta2);
          const theta2Deg = theta2 * 180 / Math.PI;
          resultHTML += `มุมหักเห = ${theta2Deg.toFixed(2)}°<br>`;

          let x2 = centerX + length * Math.sin(theta2);
          let y2 = centerY + length * Math.cos(theta2);
          ({ x: x2, y: y2 } = clampPoint(x2, y2));

          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x2, y2);
          ctx.strokeStyle = "blue";
          ctx.stroke();

          if (showAnglesCheckbox.checked) {
            // arc θ2
            drawArc(centerX, centerY, 40, Math.PI / 2 - theta2, Math.PI / 2, "blue");
            // ป้ายค่าองศาของ θ2 เคลื่อนตามมุม
            const mid2 = Math.PI / 2 - theta2 / 2;
            const lx2 = centerX + labelRadius * Math.cos(mid2) + xOffset;
            const ly2 = centerY + labelRadius * Math.sin(mid2);
            ctx.fillStyle = "blue";
            ctx.font = "16px Arial";
            drawLabel(lx2, ly2, `${theta2Deg.toFixed(1)}°`, "blue");
          }

        }
        else {
          let x2 = centerX + length * Math.sin(theta1);
          let y2 = centerY - length * Math.cos(theta1);
          ({ x: x2, y: y2 } = clampPoint(x2, y2));

          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(x2, y2);
          ctx.strokeStyle = "green";
          ctx.stroke();
          // reflection angle will be appended after warning

          if (showAnglesCheckbox.checked) {
            // arc for reflection angle (equal to θ1)
            drawArc(centerX, centerY, 40, -Math.PI / 2, -Math.PI / 2 + theta1, "green");
            const midR = -Math.PI / 2 + theta1 / 2;
            const lxR = centerX + labelRadius * Math.cos(midR) + xOffset;
            const lyR = centerY + labelRadius * Math.sin(midR);
            ctx.fillStyle = "green";
            ctx.font = "16px Arial";
            drawLabel(lxR, lyR, `${theta1Deg.toFixed(1)}°`, "green");
          }

          resultHTML += `<div class="warning">เกิดการสะท้อนกลับหมด</div>`;
          resultHTML += `มุมสะท้อนคือ ${theta1Deg}°<br>`;
        }

        resultDiv.innerHTML = resultHTML;
      }

      angleSlider.oninput = draw;
      showAnglesCheckbox.addEventListener('change', draw);
      n1Input.addEventListener("blur", () => validateInput(n1Input));
      n2Input.addEventListener("blur", () => validateInput(n2Input));

      function updateCustomVisibility(selectElem, customElem, inputElem, valueElem) {
        // keep the "ใช้ค่า:" label always visible; toggle the static span vs inline controls
        if (selectElem.value === 'custom') {
          customElem.classList.remove('hidden');
          if (valueElem) valueElem.classList.add('hidden');
          inputElem.disabled = false;
        } else {
          customElem.classList.add('hidden');
          if (valueElem) valueElem.classList.remove('hidden');
          inputElem.disabled = true;
          // sync numeric input with selected preset
          inputElem.value = parseFloat(selectElem.value).toFixed(2);
        }
        updateDisplayedValues();
        draw();
      }

      n1Select.addEventListener('change', () => updateCustomVisibility(n1Select, n1Custom, n1Input, n1ValueSpan));
      n2Select.addEventListener('change', () => updateCustomVisibility(n2Select, n2Custom, n2Input, n2ValueSpan));

      // Ensure displayed value updates immediately when selection changes
      n1Select.addEventListener('change', () => updateDisplayedValues());
      n2Select.addEventListener('change', () => updateDisplayedValues());

      n1Input.addEventListener('input', () => { updateDisplayedValues(); draw(); });
      n2Input.addEventListener('input', () => { updateDisplayedValues(); draw(); });

      // initialize visibility based on selected options
      updateCustomVisibility(n1Select, n1Custom, n1Input, n1ValueSpan);
      updateCustomVisibility(n2Select, n2Custom, n2Input, n2ValueSpan);

      // ensure displayed numeric values match initial selections
      updateDisplayedValues();

      // Responsive canvas sizing: set proper pixel size for device DPR and redraw on resize
      function resizeCanvas() {
        const containerWidth = Math.min(document.querySelector('.container').clientWidth, 900);
        const aspect = 600 / 400; // original aspect ratio
        const displayWidth = Math.max(280, containerWidth * 0.98);
        const displayHeight = Math.round(displayWidth / aspect);
        const dpr = window.devicePixelRatio || 1;
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        canvas.width = Math.floor(displayWidth * dpr);
        canvas.height = Math.floor(displayHeight * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // set controls-center to match canvas display width so the top box lines up
        if (controlsCenter) {
          if (window.innerWidth >= 900) {
            // compute a single target width so controls-center and indices match exactly
            const gapValue = parseFloat(getComputedStyle(document.querySelector('.indices')).gap) || 18;
            const canvasRendered = Math.round(canvas.getBoundingClientRect().width) || displayWidth;
            let targetTotal = canvasRendered; // use actual canvas rendered width
            // ensure each block respects its minimum width
            const minPerBlock = 260;
            const minTotal = minPerBlock * 2 + gapValue;
            if (minTotal > targetTotal) targetTotal = minTotal;
            const perBlock = (targetTotal - gapValue) / 2;

            controlsCenter.style.width = Math.round(targetTotal) + 'px';
            controlsCenter.style.margin = '12px auto';
            controlsCenter.style.boxSizing = 'border-box';

            // ensure indices uses same target total so both align
            const indices = document.querySelector('.indices');
            if (indices) indices.style.width = Math.round(targetTotal) + 'px';
          } else {
            controlsCenter.style.width = '';
            controlsCenter.style.margin = '';
            controlsCenter.style.boxSizing = '';
          }
        }

        // Make the two index blocks together match the controls-center width (respecting gap)
        const indices = document.querySelector('.indices');
        const blocks = document.querySelectorAll('.index-block');
        if (indices && blocks.length >= 2) {
          // on narrow screens let CSS handle full-width stacking
          if (window.innerWidth >= 900) {
            // use the canvas's actual rendered width so elements align exactly
            const canvasRendered = Math.round(canvas.getBoundingClientRect().width) || parseFloat(canvas.style.width) || indices.clientWidth;
            indices.style.width = canvasRendered + 'px';
            indices.style.margin = '0 auto';
            const gapValue = parseFloat(getComputedStyle(indices).gap) || 18;
            const totalW = canvasRendered;
            const perBlock = Math.max(260, (totalW - gapValue) / 2);
            blocks.forEach(b => {
              b.style.width = Math.round(perBlock) + 'px';
              b.style.boxSizing = 'border-box';
            });
          } else {
            // remove inline widths for mobile so media queries take effect
            indices.style.width = '';
            blocks.forEach(b => {
              b.style.width = '';
              b.style.boxSizing = '';
            });
          }
        }

        // set slider width proportionally to canvas (not full width) so it looks balanced
        if (angleSlider) {
          const sliderWidth = Math.round(displayWidth * 0.72); // 72% of canvas width
          angleSlider.style.width = sliderWidth + 'px';
        }

        const angleBlock = document.getElementById("angleBlockBelow");
        if (angleBlock && window.innerWidth >= 900) {
          const canvasRendered = Math.round(canvas.getBoundingClientRect().width);
          angleBlock.style.width = canvasRendered + "px";
          angleBlock.style.margin = "20px auto 8px";
          angleBlock.style.boxSizing = "border-box";
        } else if (angleBlock) {
          // mobile ใช้ค่า default จาก CSS
          angleBlock.style.width = "";
          angleBlock.style.margin = "";
          angleBlock.style.boxSizing = "";
        }

        draw();
      }

      window.addEventListener('resize', resizeCanvas);
      window.addEventListener('orientationchange', resizeCanvas);

      // init canvas size then draw
      resizeCanvas();
    </script>

</body>

</html>